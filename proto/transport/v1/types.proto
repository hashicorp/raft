syntax = "proto3";

package hashicorp.raft.transport.v1;

import "google/protobuf/timestamp.proto";

// mog annotation:
//
// target=github.com/hashicorp/raft.RPCHeader
// output=common.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message RPCHeader {
  // ProtocolVerison is the version of the protocol the sender is speaking
  int32 protocol_version = 1;

  // ID is the ServerID of the node sending the RPC Request or Response
  // mog: target=ID
  bytes id = 2;

  // Addr is the ServerAddr of the node sending theRPC Request or Response
  bytes addr = 3;
}

// mog annotation:
//
// target=github.com/hashicorp/raft.Log
// output=common.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message Log {
  // Index holds the index of the log entry.
  uint64 index = 1;

  // Term holds the election term of the log entry.
  uint64 term = 2;

  // Type holds the type of the log entry.
  uint32 type = 3;

  // Data holds the log entries type-specific data.
  bytes data = 4;

  // Extensions holds an opaque byte slice of information for middleware. It
  // is up to the client of the library to properly modify this as it adds
  // layers and remove those layers when appropriate. This value is a part of
  // the log, so very large values could cause timing issues.
  //
  // N.B. It is _up to the client_ to handle upgrade paths. For instance if
  // using this with go-raftchunking, the client should ensure that all Raft
  // peers are using a version that can handle that extension before ever
  // actually triggering chunking behavior. It is sometimes sufficient to
  // ensure that non-leaders are upgraded first, then the current leader is
  // upgraded, but a leader changeover during this process could lead to
  // trouble, so gating extension behavior via some flag in the client
  // program is also a good idea.
  bytes extensions = 5;

  // AppendedAt stores the time the leader first appended this log to it's
  // LogStore. Followers will observe the leader's time. It is not used for
  // coordination or as part of the replication protocol at all. It exists only
  // to provide operational information for example how many seconds worth of
  // logs are present on the leader which might impact follower's ability to
  // catch up after restoring a large snapshot. We should never rely on this
  // being in the past when appending on a follower or reading a log back since
  // the clock skew can mean a follower could see a log with a future timestamp.
  // In general too the leader is not required to persist the log before
  // delivering to followers although the current implementation happens to do
  // this.
  // Time validity bounds.
  // mog: func-to=TimeFromProto func-from=TimeToProto
  google.protobuf.Timestamp appended_at = 6;
}
